<?php
/**
 * @file
 * Drupal module implementation.
 *
 * @license GPL, or GNU General Public License, version 3
 * @license http://opensource.org/licenses/GPL-3.0
 * @see README.md how to contribute to this project
 */

/**
 * Implements hook_menu_alter().
 */
function uhc_course_implementation_source_menu_alter(&$items) {
  if ($items['node/add/course-implementation']) {
    $items['node/add/course-implementation']['page callback'] = 'drupal_get_form';
    $items['node/add/course-implementation']['page arguments'] = array('uhc_course_implementation_source_add_course_implementation');
    $items['node/add/course-implementation']['module'] = 'uhc_course_implementation_source';
    unset($items['node/add/course-implementation']['file']);
  }
}

/**
 * Menu callback for starting importing specified course implementation.
 */
function uhc_course_implementation_source_add_course_implementation() {
  return array(
    'container' => array(
      '#type' => 'fieldset',
      '#title' => t('Course implementation'),
      '#description' => t('Type in the course id which you want to import.'),
      'course_imp_id' => array('#type' => 'textfield', '#title' => t('Course implementation ID'), '#required' => TRUE, '#size' => 10),
    ),
    'submit' => array('#type' => 'submit', '#value' => t('Import')),
  );
}

/**
 * Validation callback for
 * uhc_course_implementation_source_add_course_implementation()
 * @param $form
 * @param $form_state
 */
function uhc_course_implementation_source_add_course_implementation_validate(&$form, &$form_state) {

  // Ensure that course implementation json object can be fetched
  $course_imp_id = $form_state['values']['course_imp_id'];
  $course_imp_json = _uhc_sources_get_json_object($course_imp_id);
  if (!$course_imp_json) {
    form_set_error('course_imp_id', t('Failed to fetch'));
  }

  // Resolve course number, so we know that which course we need to import too
  if (!$course_number = _uhc_sources_resolve_course_number($course_imp_id)) {
    form_set_error('course_imp_id', t('Could not resolve course number from course implementation id'));
  }
  $form_state['values']['course_number'] = $course_number;

}

/**
 * Submission callback for
 * uhc_course_implementation_source_add_course_implementation()
 * @param $form
 * @param $form_state
 */
function uhc_course_implementation_source_add_course_implementation_submit(&$form, &$form_state) {

  $course_imp_id = $form_state['values']['course_imp_id'];
  $course_number = $form_state['values']['course_number'];

  // Now ensure that course node exists. If it fails, then log and return
  // FALSE.
  if (!$course_node = uhc_course_source_import($course_number)) {
    watchdog('uhc_course_implementation_sources', 'Failed to ensure @course_number course presence.', array('@course_number' => $course_number), WATCHDOG_ERROR);
    drupal_set_message(t('Could not import course'), 'error');
    return;
  }

  // After we have ensured that we have referenced entity in the system we may
  // now import course implementation.
  if (!$node = uhc_course_implementation_source_import($course_imp_id)) {
    watchdog('uhc_course_implementation_sources', 'Failed to import @course_imp_id course implementation.', array('@course_imp_id' => $course_imp_id), WATCHDOG_ERROR);
    drupal_set_message(t('Could not import course implementation'), 'error');
    return;
  }

  $entity_uri = entity_uri('node', $node);
  if (!empty($entity_uri['path'])) {
    drupal_goto($entity_uri['path']);
  }
  else {
    drupal_set_message(t('Could import node, but could not find path to redirect.'));
  }
}

/**
 * Implements hook_uhc_activemq_connector_message_processor_info().
 */
function uhc_course_implementation_source_uhc_activemq_connector_message_processor_info() {
  $default_queue_name = variable_get('uhc_activemq_connector_default_queue', 'doo.local1.kurssisivu.in');
  return array(
    $default_queue_name => array(
      array('class_name' => 'UHCCourseImplementationMessageProcessor', 'implements' => 'UHCMessageQueueProcessorInterface')
    ),
  );
}

/**
 * Imports a course implementation by the given ID whether or not it exists in
 * the system.
 *
 * @param $course_imp_id
 *   The ID of the course implementation to import.
 * @return bool|object
 *   Returns FALSE if failed to import. Node object when successfully imported.
 */
function uhc_course_implementation_source_import($course_imp_id) {

  // Construct the URLs for source class
  $item_url = variable_get('uhc_course_implementation_source_item_url', '');
  $item_url = PortalMigrationBase::prependHostIfMissing($item_url);

  /** @var $migration CourseImplementationNodeMigration */
  $migration = new CourseImplementationNodeMigration(array('predefined_ids' => $course_imp_id, 'predefined_item' => $item_url));
  $migration->prepareUpdate();
  $result = $migration->processImport();
  if ($result == Migration::RESULT_COMPLETED) {

    // Use EntityFieldQuery to find out the node id. Then load and return it.
    $query = new EntityFieldQuery();
    $result = $query->entityCondition('entity_type', 'node')
      ->entityCondition('bundle', 'course_implementation')
      ->fieldCondition('field_imp_id', 'value', $course_imp_id)
      ->execute();
    if (isset($result['node'])) {
      foreach ($result['node'] as $nid => $item) {
        return node_load($nid);
      }
    }
    else {
      watchdog('uhc_course_implementation_source', 'Node with course implementation id @course_imp_id was imported but could not be loaded.', array('@course_imp_id' => $course_imp_id), WATCHDOG_ERROR);
      return FALSE;
    }

  }
  else {
    watchdog('uhc_course_implementation_source', 'Failed to process importing, migration returned "@result" as result.', array('@result' => $result), WATCHDOG_ERROR);
    return FALSE;
  }

}

/**
 * Implements hook_cron().
 *
 * @see uhc_course_implementation_source_queue_info()
 * @see _uhc_course_implementation_source_delete_item_from_queue()
 */
function uhc_course_implementation_source_cron() {
  _uhc_course_implementation_source_add_deleted_items_to_queue('uhc_course_implementation_source_delete');
}

/**
 * Implements hook_cron_queue_info().
 *
 * @see uhc_course_implementation_souce_cron()
 * @see _uhc_course_implementation_source_add_deleted_items_to_queue()
 * @see _uhc_course_implementation_source_delete_item_from_queue()
 */
function uhc_course_implementation_source_cron_queue_info() {

  // Don't use more than two minutes deleting items.
  $seconds = 120;

  return array(
    'uhc_course_implementation_source_delete' => array(
      'worker callback' => '_uhc_course_implementation_source_delete_item_from_queue',
      'time' => $seconds,
    ),
  );
}

/**
 * Add deleted items to given queue since last call.
 * @param $queue_name
 */
function _uhc_course_implementation_source_add_deleted_items_to_queue($queue_name) {

  // Construct list URL
  $list_url = variable_get('uhc_course_implementation_source_list_url', '');
  $list_url = PortalMigrationBase::prependHostIfMissing($list_url);

  // Replace :since_date parameter in URL. Our timestamps are in local time, but
  // requests must be converted to Zulu time.
  $last_requested = new DateTime();
  $last_requested->setTimestamp(variable_get('uhc_course_implementation_source_deleted_last_requested', strtotime('-1 month', REQUEST_TIME)));
  $last_requested->setTimezone(new DateTimeZone('Etc/Zulu'));
  $list_url = str_replace(':since_date', $last_requested->format('Y-m-d\TH:i:s\.000\Z'), $list_url);

  // Get changed items and filter deleted ids from it and put them to delete
  // queue.
  $changed_items = _uhc_course_implementation_source_get_changed_items($list_url);
  if (is_array($changed_items)) {

    // Filter deleted ids out from changed items and queue them for deletion
    $deleted_ids = _uhc_course_implementation_source_filter_deleted_ids($changed_items);
    /** @var DrupalReliableQueueInterface $queue */
    $queue = DrupalQueue::get($queue_name, TRUE);
    while ($deleted_id = array_shift($deleted_ids)) {
      $queue->createItem($deleted_id);
    }

    // Update last requested timestamp, so next call will be offset from here
    variable_set('uhc_course_implementation_source_deleted_last_requested', REQUEST_TIME);

  }

}

/**
 * Helper function for getting changes items.
 *
 * @param $list_url
 *   Absolute URL containing list of changed items.
 * @return array|bool
 *   Returns an array (with items or empty) when reponse was valid. When
 *   response was invalid it will return boolean FALSE.
 */
function _uhc_course_implementation_source_get_changed_items($list_url) {
  // Request given list URL
  $timeout = variable_get('uhc_sources_timeout', ini_get('default_socket_timeout'));
  $response = drupal_http_request($list_url, array('timeout' => $timeout));
  if ($response->code != 200) {
    watchdog('uhc_course_implementation_source', 'Course implementation changes endpoint responded with status @status', array('@status' => $response->code), WATCHDOG_WARNING);
    return FALSE;
  }

  // Ensure we have response payload
  $payload = $response->data;
  if (empty($payload)) {
    // We got 200 but no response contents?
    watchdog('uhc_course_implementation_source', 'Course implementation changes endpoint responded with status @status while having empty payload', array('@status' => $response->code), WATCHDOG_WARNING);
    return FALSE;
  }

  // Expect JSON and decode it
  $json_decoded = json_decode($payload);
  if (is_null($json_decoded)) {
    watchdog('uhc_course_implementation_source', 'Course implementation changes endpoint responded with status @status but could not decode json response @response', array('@status' => $response->code, '@response' => $payload), WATCHDOG_WARNING);
    return FALSE;
  }

  // TODO: Check data integrity
  // As from here, we assume that response is valid, therefore process it.
  if (!empty($json_decoded->data) && is_array($json_decoded->data)) {
    return $json_decoded->data;
  }

  // Response was considered valid but "empty", therefore return empty array
  // instead boolean FALSE
  return array();

}

/**
 * Helper function for filtering deleted IDs out from given changed items.
 * @param array $changed_items
 * @return array
 */
function _uhc_course_implementation_source_filter_deleted_ids(array $changed_items) {
  $deleted_ids = array();
  // Loop each item and filter only deleted items.
  foreach ($changed_items as $item) {
    $item = (array) $item;
    if (PortalListBase::isDeleted($item)) {
      $deleted_ids[] = $item['course_id'];
    }
  }
  return $deleted_ids;
}

/**
 * Process queued item which should remove the item.
 * @param $id
 */
function _uhc_course_implementation_source_delete_item_from_queue($id) {
  // Utilize MigrateSQLMap class for resolving mapping from given ID
  $map = new MigrateSQLMap('CourseImplementationNode', array('id'), array('nid'));
  if ($row = $map->getRowBySource(array($id))) {

    // After following treatment, we'll not end up having mapping row anymore
    // after this.
    $map->delete(array($id));

    // If it was in the system before, but has been deleted in Drupal by other
    // means. We just leave log entry in this case (and clean it up).
    if (empty($row['destid1'])) {
      watchdog('uhc_course_implementation_source', 'Resolved ID @id during queue deletion worker process, but no destination was found. Mapping row was deleted.', array('@id' => $id), WATCHDOG_WARNING);
      return;
    }

    watchdog('uhc_course_implementation_source', 'Deleting node @nid which was resolved from id @id (and mapping row will be deleted)', array('@nid' => $row['destid1'], '@id' => $row['sourceid1']), WATCHDOG_INFO);
    node_delete($row['destid1']);

  }
  else {
    // We hit here when we can't find corresponding node for given ID. Can
    // happen if something very old was deleted or it couldn't have a chance to
    // get imported in the first place.
    watchdog('uhc_course_implementation_source', 'Failed resolving ID @id during queue deletion worker process. Nothing was done (queue item will be deleted).', array('@id' => $id), WATCHDOG_INFO);
  }
}
